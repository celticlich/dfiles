# Broken out from .zsh_aliases
# BMF - 260520

# ##################################################################
# Functions
# ##################################################################

# ##################################################################
# Docker Functions
# ##################################################################
dkclean() {
		  sudo docker rm $(docker ps --all -q -f status=exited)
		    sudo docker volume rm $(docker volume ls -qf dangling=true)
			
}

dkln() {
  sudo docker logs -f `docker ps | grep $1 | awk '{print $1}'`
}

dktop() {
  sudo docker stats --format "table {{.Container}}\t{{.Name}}\t{{.CPUPerc}}  {{.MemPerc}}\t{{.NetIO}}\t{{.BlockIO}}"
}

dkstats() {
  if [ $# -eq 0 ]
    then sudo docker stats --no-stream;
    else sudo docker stats --no-stream | grep $1;
  fi
}

# ##################################################################
# Container updates
# ##################################################################

plex-update() { # bring down plex container and pull new image
cd /opt/docker
docker-compose down;
docker-compose pull;
docker-compose up -d
}

unifi-update() { # bring down unifi container and pull new image
cd /opt/docker/unifi
docker-compose down;
docker-compose pull;
docker-compose up -d
}

media-update() { # bring down media-stack container and pull new image
cd /opt/docker/
docker-compose down;
docker-compose pull;
docker-compose up -d
}

testcron() { # test crontab entries for errors
 crontab -l | grep -v '^#' | cut -f 6- -d ' ' | while read CMD; do eval $CMD; done
}

seekkill () { # find and kill process by name with fzf
		ps aux | fzf | awk '{print $2}' | xargs kill -9
}

old() { # Backup a file with the extension '.old'
	   	cp --reflink=auto "${1}"{,.old} 2>/dev/null || cp "${1}"{,.old}; 
}
get_command() {  # Functionalise 'command -v' to allow 'if get_command [command]' idiom
		command -v "${1}" &>/dev/null; 
}
printline() { # A function to print a specific line from a file
  # If $1 is empty, print a usage message
  if [[ -z "${1}" ]]; then
    printf '%s\n' "Usage:  printline n [file]" ""
    printf '\t%s\n' "Print the Nth line of FILE." "" \
      "With no FILE or when FILE is -, read standard input instead."
    return 0
  fi

  # Check that $1 is a number, if it isn't print an error message
  # If it is, blindly convert it to base10 to remove any leading zeroes
  case $1 in
    (''|*[!0-9]*) printf '%s\n' "[ERROR] printline: '${1}' does not appear to be a number." "" \
                    "Run 'printline' with no arguments for usage.";
                  return 1 ;;
    (*)           local lineNo="$((10#$1))" ;;
  esac

  # Next, if $2 is set, check that we can actually read it
  if [[ -n "${2}" ]]; then
    if [[ ! -r "${2}" ]]; then
      printf '%s\n' "[ERROR] printline: '$2' does not appear to exist or I can't read it." "" \
        "Run 'printline' with no arguments for usage."
      return 1
    else
      local file="${2}"
    fi
  fi

  # Finally after all that testing is done, we throw in a cursory test for 'sed'
  if is_command sed; then
    sed -ne "${lineNo}{p;q;}" -e "\$s/.*/[ERROR] printline: End of stream reached./" -e '$ w /dev/stderr' "${file:-/dev/stdin}"
  # Otherwise we print a message that 'sed' isn't available
  else
    printf '%s\n' "[ERROR] printline: This function depends on 'sed' which was not found."
    return 1
  fi
}

fuzzpass() { # fuzzy password searching
    local arg
	arg=$1
	if [ -z $# eq 0 "$arg" ]; then
			echo "password | secret key | totp"
	fi
	# if [ -z $arg ]; then
	# 		echo "password | secret key | totp"
	# 		exit 1
	# fi
    local item
    item=$(1pass | fzf);
	echo "$item"
    1pass -p "$item" "$arg"
}

tm () { # switch between tmux sessions or create new if not
		# usage: tm <name/number>
		#
	[[ -n "$TMUX" ]] && change="switch-client"  || change="attach-session" 
	if [ $1 ]
	then
		tmux $change -t "$1" 2> /dev/null || (
			tmux new-session -d -s $1 && tmux $change -t "$1"
		)
		return
	fi
	session=$(tmux list-sessions -F "#{session_name}" 2>/dev/null | fzf --exit-0)  && tmux $change -t "$session" || echo "No sessions found."
}

function notify { #notify from terminal
		terminal-notifier -title "$1" -message "$2" 
}

rtvb() { #declare Firefox as browser just for rtv and launch rtv
		export BROWSER="/Applications/Firefox.app"
		rtv --theme solarized-dark
}

tkillpane () { #kill tmux panes by number
		local inst=$(tmux list-panes | eval "fzf ${FZF_DEFAULT_OPTS} -m --header='[tmux:kill-pane]'")
		if [[ -n $inst ]]
		then
				for pane in $(echo $inst)
				do
						killpane=$(echo $pane | awk '{ print $1 }' | sed -e 's/\://g')
						tmux kill-pane -t "$killpane" 2> /dev/null
				done
		fi
}
function _calcram() { #used for ram and rams
    local sum
    sum=0
    for i in `ps aux | grep -i "$1" | grep -v "grep" | awk '{print $6}'`; do
        sum=$(($i + $sum))
    done
    sum=$(echo "scale=2; $sum / 1024.0" | bc)
    echo $sum
}

function ram() { #shows ram usages by specified process
    local sum
    local app="$1"
    if [ -z "$app" ]; then
        echo "First argument - pattern to grep from processes"
        return 0
    fi
    sum=$(_calcram $app)
    if [[ $sum != "0" ]]; then
        echo "${fg[blue]}${app}${reset_color} uses ${fg[green]}${sum}${reset_color} MBs of RAM"
    else
        echo "No active processes matching pattern '${fg[blue]}${app}${reset_color}'"
    fi
}

function rams() { # ongoing ram usage
    local sum
    local app="$1"
    if [ -z "$app" ]; then
        echo "First argument - pattern to grep from processes"
        return 0
    fi

    while true; do
        sum=$(_calcram $app)
        if [[ $sum != "0" ]]; then
                echo -en "${fg[blue]}${app}${reset_color} uses ${fg[green]}${sum}${reset_color} MBs of RAM\r"
        else
                echo -en "No active processes matching pattern '${fg[blue]}${appt}${reset_color}'\r"
        fi
        sleep 1
  done
}

fzf_alias() { # for existing aliases
  alias | tr = "\t" | fzf | cut -f 1
} 


e () { # browse edge history
        local cols sep
        cols=$(( COLUMNS / 3 ))
        sep='{::}'
        cp -f ~/Library/Application\ Support/Microsoft\ Edge/Default/History /tmp/h
        sqlite3 -separator $sep /tmp/h "select substr(title, 1, $cols), url
     from urls order by last_visit_time desc" | awk -F $sep '{printf "%-'$cols's  \x1b[36m%s\x1b[m\n", $1, $2}' | fzf --ansi --multi | sed 's#.*\(https*://\)#\1#' | xargs open
}

c() { #browse chrome history
  local cols sep
  cols=$(( COLUMNS / 3 ))
  sep='{::}'

  cp -f ~/Library/Application\ Support/Google/Chrome/Default/History /tmp/h

  sqlite3 -separator $sep /tmp/h \
    "select substr(title, 1, $cols), url
     from urls order by last_visit_time desc" |
  awk -F $sep '{printf "%-'$cols's  \x1b[36m%s\x1b[m\n", $1, $2}' |
  fzf --ansi --multi | sed 's#.*\(https*://\)#\1#' | xargs open
}

# -------------------------------------------------------------------
# compressed file expander
# (from https://github.com/myfreeweb/zshuery/blob/master/zshuery.sh)
# -------------------------------------------------------------------
ex() { # compressed file expander
    if [[ -f $1 ]]; then
        case $1 in
          *.tar.bz2) tar xvjf $1;;
          *.tar.gz) tar xvzf $1;;
          *.tar.xz) tar xvJf $1;;
          *.tar.lzma) tar --lzma xvf $1;;
          *.bz2) bunzip $1;;
          *.rar) unrar $1;;
          *.gz) gunzip $1;;
          *.tar) tar xvf $1;;
          *.tbz2) tar xvjf $1;;
          *.tgz) tar xvzf $1;;
          *.zip) unzip $1;;
          *.Z) uncompress $1;;
          *.7z) 7z x $1;;
          *.dmg) hdiutil mount $1;; # mount OS X disk images
          *) echo "'$1' cannot be extracted via >ex<";;
    esac
    else
        echo "'$1' is not a valid file"
    fi
}

### BREW + FZF
# update multiple packages at once
# mnemonic [B]rew [U]pdate [P]lugin

bip () { # install brew packages
local inst=$(brew search | eval "fzf ${FZF_BREW_OPTS} -m --header='[brew:install]'")

if [[ $inst ]]; then
  for prog in $(echo $inst)
  do brew install $prog
  done
fi
}

bup () { ### BREW + FZF # update multiple packages at once, async

local upd=$(brew leaves | eval "fzf ${FZF_DEFAULT_OPTS} -m --header='[brew:update]'")

if [[ $upd ]]; then
  for prog in $(echo $upd)
  do brew upgrade $prog
  done
fi
}

bcp () {	### BREW + FZF # mnemonic [B]rew [U]ninstall [P]lugin

local uninst=$(brew leaves | eval "fzf ${FZF_DEFAULT_OPTS} -m --header='[brew:clean]'")

if [[ $uninst ]]; then
  for prog in $(echo $uninst)
  do brew uninstall $prog
  done
fi
}

### BREW CASK + FZF
# Install or open the webpage for the selected application 
# using brew cask search as input source
# and display a info quickview window for the currently marked application
install-cask() {
    local token
    token=$(brew search --casks | fzf-tmux --query="$1" +m --preview 'brew cask info {}')

    if [ "x$token" != "x" ]
    then
        echo "(I)nstall or open the (h)omepage of $token"
        read input
        if [ $input = "i" ] || [ $input = "I" ]; then
            brew cask install $token
        fi
        if [ $input = "h" ] || [ $input = "H" ]; then
            brew cask home $token
        fi
    fi
}
# Uninstall or open the webpage for the selected application 
# using brew list as input source (all brew cask installed applications) 
# and display a info quickview window for the currently marked application
uninstall-cask() {
    local token
    token=$(brew cask list | fzf-tmux --query="$1" +m --preview 'brew cask info {}')

    if [ "x$token" != "x" ]
    then
        echo "(U)ninstall or open the (h)omepage of $token"
        read input
        if [ $input = "u" ] || [ $input = "U" ]; then
            brew cask uninstall $token
        fi
        if [ $input = "h" ] || [ $token = "h" ]; then
            brew cask home $token
        fi
    fi
}

# yadm functions

yadm::inside_work_tree () {
        yadm rev-parse --is-inside-work-tree > /dev/null
}

yadm::log () {
	yadm::inside_work_tree || return 1
	local cmd opts
	cmd="echo {} |grep -Eo '[a-f0-9]+' |head -1 |xargs -I% yadm show --color=always % $* | $forgit_pager" 
	opts="
         $FORGIT_FZF_DEFAULT_OPTS
         +s +m --tiebreak=index --preview=\"$cmd\"
         --bind=\"enter:execute($cmd | LESS='-R' less)\"
         --bind=\"ctrl-y:execute-silent(echo {} |grep -Eo '[a-f0-9]+' | head -1 | tr -d '\n' |${FORGIT_COPY_CMD:-       pbcopy})\"
         $FORGIT_LOG_FZF_OPTS
     " 
	eval "yadm log --graph --color=always --format='%C(auto)%h%d %s %C(black)%C(bold)%cr' $* $forgit_emojify" | FZF_DEFAULT_OPTS="$opts" fzf
}

yadm::add () {
	yadm::inside_work_tree || return 1
	[[ $# -ne 0 ]] && yadm add "$@" && return
	local changed unmerged untracked files opts preview extract
	changed=$(yadm config --get-color color.status.changed red) 
	unmerged=$(yadm config --get-color color.status.unmerged red) 
	untracked=$(yadm config --get-color color.status.untracked red) 
	extract="
         sed 's/^.*]  //' |
         sed 's/.* -> //' |
         sed -e 's/^\\\"//' -e 's/\\\"\$//'" 
	preview="
         file=\$(echo {} | $extract)
         if (yadm status -s -- \$file | grep '^??') &>/dev/null; then  # diff with /dev/null for untracked files
             yadm diff --color=always --no-index -- /dev/null \$file | $forgit_pager | sed '2 s/added:/untracked:/'
         else
             yadm diff --color=always -- \$file | $forgit_pager
         fi" 
	opts="
         $FORGIT_FZF_DEFAULT_OPTS
         -0 -m --nth 2..,..
         --preview=\"$preview\"
         $FORGIT_ADD_FZF_OPTS
     " 
	files=$(yadm -c color.status=always -c status.relativePaths=true status -su |
         grep -F -e "$changed" -e "$unmerged" -e "$untracked" |
         sed -E 's/^(..[^[:space:]]*)[[:space:]]+(.*)$/[\1]  \2/' |
         FZF_DEFAULT_OPTS="$opts" fzf |
         sh -c "$extract") 
	[[ -n "$files" ]] && echo "$files" | tr '\n' '\0' | xargs -0 -I% yadm add % && yadm status -su && return
	echo 'Nothing to add.'
}
yadm::diff () {
	yadm::inside_work_tree || return 1
	local cmd files opts commit repo
	[[ $# -ne 0 ]] && {
		if yadm rev-parse "$1" -- &> /dev/null
		then
			commit="$1"  && files=("${@:2}") 
		else
			files=("$@") 
		fi
	}
	repo="$(yadm rev-parse --show-toplevel)" 
	target="\$(echo {} | sed 's/.*]  //')" 
	cmd="yadm diff --color=always $commit -- $repo/$target | $forgit_pager" 
	opts="
        $FORGIT_FZF_DEFAULT_OPTS
        +m -0 --preview=\"$cmd\" --bind=\"enter:execute($cmd |LESS='-R' less)\"
        $FORGIT_DIFF_FZF_OPTS
    " 
	eval "yadm diff --name-status $commit -- ${files[*]} | sed -E 's/^(.)[[:space:]]+(.*)$/[\1]  \2/'" | FZF_DEFAULT_OPTS="$opts" fzf
}
